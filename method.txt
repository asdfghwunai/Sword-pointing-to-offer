数据结构是链表，数组，字符串，树
解决办法有双指针，二分，哈希，排序，递归，回溯，位运算，bfs，dfs，暴力，三大遍历思想，partition，归并思想，剑指offer也就这些了

-------数组------头尾指针查找和快慢指针去重
杂乱的数组题要么先排序，然后去找规律（扑克顺子）；
要么根据什么map（红黑树）插入排序，不是unorded_map（哈希表）（前提是没有一样的）（数据流的中位数）

压缩从头用快慢指针，展开从尾用快慢指针

只要是排序数组都是大方向用二分查找法（头尾索引法）
杂乱的数组求top k可以直接用partition或堆排来查找
有时候偷懒法就用哈希（数组中重复的数字，数组中出现次数超过一半的数字也可以用partition）

想加快时间效率就得有一些技巧了，发现不了啊
要么直接发现规律跳过一些计算(比如1-n中1出现的次数)，要么开辟一个空间，后面的计算依赖前面的(比如丑数)，要么直接用现成的算法（比如统计逆序对（归并），
排序数组中某个数出现次数（二分），最小的k个数（partition））

有的直接从头遍历就行了(比如调整数组顺序使奇数位于偶数前面,连续子数组的最大和)
找到数组中要排序的长度（一次从左到右遍历，找最大的，且最后一个小于最大的记为right；一次从右到左）

还有也用到回溯，比如找到数组中和为sum组合的问题(归结为放与不放问题，可用回溯法)

最近经常看到一种类似桶排序的算法，先声明那么大的空间，再一点点填标志位1，最后看是1的标志的下标，和bitmap很像啊


----------链表--------快慢指针
只要是单链表题大多数都是双指针法
指针或三指针法(适合数组类和指针类，往往和迭代掺到一起)
它这里面的分治是分步走的意思，比如复杂链表的复制

-------二叉树------分割大法+递归
二叉树类型题都是和递归有关，好多题都是前序中序后序的变形

看到搜索树直接想到中序，中序是排好序，前序和后序是你自己分，根节点在两端，很少出现(二叉搜索树的后序遍历序列)；其他直接想到前序或后序，
同样中序很少出现(比如二叉树的下一个节点)

要么是单纯的遍历;要么是分割+递归，比如重建二叉树、后序遍历序列
也用到BFS，如按层打印
也用到回溯，比如保存路径

------字符串------
用到头尾指针，快慢指针，递归，回溯等, 哈希

-----位运算------
计算问题问了都是用位运算优化
比如数组中出现一次的数字，这个性质我怎么可能知道呢？（听别人说你不会就可以想位运算）

异或非常适合找那种单一的数（找出出现奇数次的元素，找出数组中唯一的重复元素）

一般都会用到异或,移位


=======-技巧==========
一条道走到黑法(选择一条正确的路，中间有任何异常返回假，适合做那种判断是不是真的题，这种往往又和递归掺到一起)
和时间效率有关的题暴力求解法（就是根据一个规则一个一个判断）都能做，就是会超时，这时要么通过观察大法少判断一些情况，要么用空间换时间

-----双指针----快慢指针和头尾指针
1.适合快慢指针的情况，注意字符串替换空格，合并两个有序数组（有个数组有足够空间放合并后的）可以用从尾到头双指针法
2.适合头尾指针的情况，数组查找，分堆

-------二分--------用到头尾指针
除了原版是找目标值，现在题上的都是找坐标呢，这时都是=mid，不是mid-1，你注意一下

---------栈-------保存中间结果
栈这东西也挺常见的，构造带有min功能的栈，保存路径等，保存遍历过的节点等（先进后出的特性）
栈会让东西反转（什么时候想让链表节点翻转就用栈，我看java栈类型是Node啊）
栈也可以像一个普通的容器存放一下，那还不如用vector，省的反转了

------哈希-----快速查找
哈希这东西可以去重，和bitmap一样，链表去重无序用哈希，有序用双指针法，或者无序先排序再双指针

-----迭代和递归----保证处理子过程是通用的
突然发现链表适合迭代，二叉树适合递归

=========思路===========
-----做题感觉------
1.题要么是查找，要么是排序
2.你不得先定个数据类型接收所有的输入啊
3.差不多都是50行以内
4.重要的是思考过程，不是答案啊
5.把主要过程先用函数填充好框架，再去设计函数，就是分步走，比如复杂链表的复制
6.把一道大点的题分解成你做过的几小步

-----怎么找到思路------
1.想类似题
2.从任意一个情况开始分析
若都没有太好的思路，先随便分析一种情况，或许分析着分析着思路就出来了。
3.从简单情况分析
4.暴力打表法来找一定规律

----尝试顺序----
1.用些数据结构相关算法，比如双指针，二分，partition，merge，bfs，dfs，前中后序遍历
2.用些编程思想，比如暴力枚举，递归(分解成子问题，包括分治)，回溯(为了列举所有情况)，贪心，动态规划
3.尝试些算法技巧，比如查表，模拟，建模，分治
//递归好乱套，好多都用到递归

======思想========
现在感觉好难啊，估计笔试都过不了啊。。。。

----暴力搜索法----
1.简单枚举法是一一列举所有数,并在列举过程中计算，比如算1到n的立方
2.搜索法是一个数组就摆在那，然后你去搜索。。比如在一个数组中找一个数在不在，可以直接搜也可以排序后(二分)或建hash_table再查找
3.暴力法就是一种试错法，而直接法是根据问题直接推出答案，一阴一阳

----回溯法--------为了保存所有符合的结果，重点是进入和回退状态，不可少的
1.当前不符合就返回，符合就进到下一维度，比如字符串排列（后序递归），是在孩子基础上做的
2.可以有条件递归来找到解决方案就结束，感觉就是有条件前序遍历，设置少一点可以少遍历一点，有进必有出，你钻的越深越需要出来
2.剪枝就是访问数组
3.回溯法就是先进入一个状态，弄完答案再回退，比如sum的组合(放后和不放)

----动态规划----重点是选与不选
1.子问题有重合，比如算斐波那契数列被重复计算，可以用查表法做
2.貌似这个表写入就不动了啊，先算最小子问题
3.首先先构造基本情况，后面情况是在前面基础上进行比较，好了就覆盖;
3.背包问题想保存中间用二维，不想用一维

----贪心法----也是找最优解，有的问题按贪心规则就是最优解
1.拟定一个填答案原则，问题必须满足贪心性质，不然不能全部通过
2.贪心得先排序，自己构造cmp函数

----递归/迭代------递归的目的就是为了分割成更小的问题
0.总结一个都适用的规律
1.迭代是用while，递归是if
2.迭代是在一个圈里转来转去，递归就是一点点往下层钻



=====高级算法技巧======
1.查表法
记录表并查表(计算过程中记录或事前记录(你可以写死到表里))
应用场景:解决重复计算问题

2.分支限界法
先分段,再在符合的段里算,再接着细分,怎么这么像partition呢?partition分两段
应用场景:求連續函數的極值

3.建模法
就是用一种数据结构来转化原问题,直接在数据结构上来解答,比如杀人游戏就是queue

4.模拟法
就是模拟实际运作来看效果..比如看俩筛子一样不,就可以模拟转动

5.分治法
子问题没有重合，先划分成子问题，只要解决一点点解决各个子问题就行
把一个大问题分割成几个小问题,一个个解决,把结果合并,比如归并排序

6.递增法
就是一步一个脚印,老老实实来,一步一步解决问题,比如选择排序

7.缩放法
适合数值计算问题,猜一下,比如算那些方块的总面积,一个小方块长度固定,是小数,可以映射到整数,再最后映射回来
