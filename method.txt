数据结构是链表，数组，字符串，树
解决办法有双指针，二分，哈希，排序，递归，回溯，位运算，bfs，dfs，暴力，三大遍历思想，partition，归并思想，剑指offer也就这些了

-------数组------头尾指针查找和快慢指针去重
杂乱的数组题要么先排序，然后去找规律（扑克顺子）；
要么根据什么map（红黑树）插入排序，不是unorded_map（哈希表）（前提是没有一样的）（数据流的中位数）

只要是排序数组都是大方向用二分查找法（头尾索引法）
杂乱的数组求top k可以直接用partition或堆排来查找
有时候偷懒法就用哈希（数组中重复的数字，数组中出现次数超过一半的数字也可以用partition）

想加快时间效率就得有一些技巧了，发现不了啊
要么直接发现规律跳过一些计算(比如1-n中1出现的次数)，要么开辟一个空间，后面的计算依赖前面的(比如丑数)，要么直接用现成的算法（比如统计逆序对（归并），
排序数组中某个数出现次数（二分），最小的k个数（partition））

有的直接从头遍历就行了(比如调整数组顺序使奇数位于偶数前面,连续子数组的最大和)

最近经常看到一种类似桶排序的算法，先声明那么大的空间，再一点点填标志位1，最后看是1的标志的下标，和bitmap很像啊


----------链表--------快慢指针
只要是单链表题大多数都是双指针法
指针或三指针法(适合数组类和指针类，往往和迭代掺到一起)
它这里面的分治是分步走的意思，比如复杂链表的复制

-------二叉树------分割大法+递归
二叉树类型题都是和递归有关，好多题都是前序中序后序的变形

看到搜索树直接想到中序，中序是排好序，前序和后序是你自己分，根节点在两端，很少出现(二叉搜索树的后序遍历序列)；其他直接想到前序或后序，
同样中序很少出现(比如二叉树的下一个节点)

要么是单纯的遍历;要么是分割+递归，比如重建二叉树、后序遍历序列
也用到BFS，如按层打印
也用到回溯，比如保存路径

------字符串------
用到头尾指针，递归，回溯等

-----位运算------
计算问题问了都是用位运算优化
比如数组中出现一次的数字，这个性质我怎么可能知道呢？（听别人说你不会就可以想位运算）


=======-技巧==========
一条道走到黑法(选择一条正确的路，中间有任何异常返回假，适合做那种判断是不是真的题，这种往往又和递归掺到一起)
和时间效率有关的题暴力求解法（就是根据一个规则一个一个判断）都能做，就是会超时，这时要么通过观察大法少判断一些情况，要么用空间换时间

-----双指针----快慢指针和头尾指针
1.适合快慢指针的情况，注意字符串替换空格，合并两个有序数组（有个数组有足够空间放合并后的）可以用从尾到头双指针法
2.适合头尾指针的情况，数组查找，分堆

-------二分--------用到头尾指针
除了原版是找目标值，现在题上的都是找坐标呢，这时都是=mid，不是mid-1，你注意一下

---------栈-------保存中间结果
栈这东西也挺常见的，构造带有min功能的栈，保存路径等，保存遍历过的节点等（先进后出的特性）
栈会让东西反转（什么时候想让链表节点翻转就用栈，我看java栈类型是Node啊）
栈也可以像一个普通的容器存放一下，那还不如用vector，省的反转了

------哈希-----快速查找
哈希这东西可以去重，和bitmap一样，链表去重无序用哈希，有序用双指针法，或者无序先排序再双指针

-----迭代和递归----保证处理子过程是通用的
突然发现链表适合迭代，二叉树适合递归



==========思想===============
现在感觉好难啊，估计笔试都过不了啊。。。。

-------------枚举--------
有for循环的都是枚举，枚举就是一条条地列出并计算每条记录。 
暴力搜索也是枚举的应用，也可以先排序就是整理一下再搜索，比如用快排或hash table


-------贪心算法------也是找最优解，有的问题按贪心规则就是最优解
如果是不适合贪心，你用了贪心能得到近似最优解
想用贪心算法得这个问题满足贪心性质才行，不然就不能全对，一般要把有的通过一个排序规则进行排序

--------动态规划------
一般你看到要最优解的肯定要用这个了
首先先构造基本情况，后面情况是在前面基础上进行比较，好了就覆盖;

--------回溯------
1.感觉就是有条件前序遍历，设置少一点可以少遍历一点，有进必有出，你钻的越深越需要出来
2.剪枝就是访问数组

-------while循环---
1.总结一个都适用的规律


-----做题感觉------
1.题要么是查找，要么是排序
2.你不得先定个数据类型接收所有的输入啊
3.差不多都是50行以内
4.重要的是思考过程，不是答案啊
5.把主要过程先用函数填充好框架，再去设计函数，就是分步走，比如复杂链表的复制
6.把一道大点的题分解成你做过的几小步

